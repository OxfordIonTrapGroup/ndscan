r"""This package contains abstractions for the data source of a plot, and several
implementations thereof.

This is a fairly thin layer above the results (meta)data generated by experiments,
addressing two main points:

 * We want to use the same type of plot (1D/2D/…) in several different contexts – not
   only as the top-level scan while an experiment is running, but also to display
   subscans, or for displaying ARTIQ HDF5 files after the fact.
 * The data we want to show is dynamic: new data points come in over time as an
   experiment is running, fits are recomputed, the user might select a different
   point to display a subscan for, and so on. We want to react to those changes, yet
   avoid re-creating the entire hierarchy of plot objects on every update to keep the
   user interface responsive.

To achieve this, the data for a given plot is represented as a tree of ``QObject``\ s
that emit signals when their direct children changed in a specific way (e.g.
``channel_schemata_changed``, ``points_appended``, …).

(This is somewhat of an ad-hoc solution which works well since the described data model
is fairly small in complexity; a more principled approach for creating models with
different granularities of change tracking might be more appropriate for more complex
situations.)
"""

import logging
from collections.abc import Callable
from typing import Any, Optional

import numpy

from ..._qt import QtCore
from .online_analysis import OnlineNamedFitAnalysis

logger = logging.getLogger(__name__)


class Context(QtCore.QObject):
    """Describes the environment in which a certain plot is displayed.

    This is the moral equivalent of a container for global variables and should be used
    only sparsely (i.e. for actual properties of the environment).
    """

    source_id_changed = QtCore.pyqtSignal(str)

    def __init__(self, set_dataset: Callable[[str, Any], None] = None):
        super().__init__()
        self._set_dataset = set_dataset
        self._source_id = "<unknown>"

    def get_source_id(self):
        """Return a short string that helps the user to identify the data source.

        This is usually based on the run id, and shown in plots for data traceability
        purposes.
        """
        return self._source_id

    def set_source_id(self, source_id):
        if self._source_id != source_id:
            self._source_id = source_id
            self.source_id_changed.emit(source_id)

    def is_online_master(self) -> bool:
        """Return whether the plot is run in an environment where there is a connection
        to an ARTIQ master (as opposed to e.g. displaying an offline results file).
        """
        return self._set_dataset is not None

    def set_dataset(self, key: str, value: Any) -> None:
        """Sets dataset ``key`` to ``value`` on the connected master, if any.

        See: :meth:`is_online_master`.
        """
        self._set_dataset(key, value)


class AnnotationDataSource(QtCore.QObject):
    changed = QtCore.pyqtSignal()

    def get(self) -> Any:
        raise NotImplementedError


class FixedDataSource(AnnotationDataSource):
    def __init__(self, value):
        super().__init__()
        self._value = value

    def get(self) -> Any:
        return self._value

    def set(self, value: Any) -> None:
        # Values could be NumPy arrays, so since NumPy blatantly disregards the Python
        # object model and does not return a bool-ish value (but an array of bools),
        # need to use array_equal().
        if numpy.array_equal(value, self._value):
            return
        self._value = value
        self.changed.emit()


class OnlineAnalysisDataSource(AnnotationDataSource):
    def __init__(self, analysis, key):
        super().__init__()
        self._analysis = analysis
        self._analysis.updated.connect(self.changed)
        self._key = key

    def get(self) -> Any:
        return self._analysis.get_data().get(self._key, None)


class Annotation:
    def __init__(
        self,
        kind: str,
        parameters: dict[str, Any],
        coordinates: dict[str, AnnotationDataSource],
        data: dict[str, AnnotationDataSource],
    ):
        self.kind = kind
        self.parameters = parameters
        self.coordinates = coordinates
        self.data = data


class Root(QtCore.QObject):
    """The root of a plot data tree, i.e. all the data making up a given (sub)plot.

    This is a reference to (at most) one :class:`Model`, but the value can be ``None``,
    and a signal is raised when the model changes.

    This makes it possible to handle situations where we are still waiting for the
    experiment to set the top-level metadata datasets, or the user has not yet selected
    a point for which to show a subscan.
    """

    model_changed = QtCore.pyqtSignal(object)
    title_changed = QtCore.pyqtSignal(str)

    def get_model(self) -> Optional["Model"]:
        raise NotImplementedError

    def get_title(self) -> str:
        """Return a human-readable title describing what this data tree represents,
        suitable for window/dock/… title bars.
        """
        raise NotImplementedError


class Model(QtCore.QObject):
    channel_schemata_changed = QtCore.pyqtSignal(dict)

    def __init__(self, schema_revision: int, context: Context):
        super().__init__()
        self.context = context
        self.schema_revision = schema_revision

    def get_channel_schemata(self) -> dict[str, Any]:
        raise NotImplementedError


class SinglePointModel(Model):
    point_changed = QtCore.pyqtSignal(object)

    def get_point(self) -> dict[str, Any] | None:
        raise NotImplementedError


class ScanModel(Model):
    points_rewritten = QtCore.pyqtSignal(dict)
    points_appended = QtCore.pyqtSignal(dict)
    annotations_changed = QtCore.pyqtSignal(list)

    def __init__(
        self, axes: list[dict[str, Any]], schema_revision: int, context: Context
    ):
        super().__init__(schema_revision, context)
        self.axes = axes
        self._annotations = []
        self._annotation_schemata = []
        self._online_analyses = {}

    def get_point_data(self) -> dict[str, Any]:
        raise NotImplementedError

    def get_annotations(self) -> list[Annotation]:
        return self._annotations

    def get_analysis_result_source(self, name: str) -> AnnotationDataSource | None:
        raise NotImplementedError

    #
    # TODO: Having these as elaborate implementation in the base class leaves a bit of a
    # bad aftertaste, although it's slightly hard to qualify why it should be bad
    # design.
    #

    def _set_annotation_schemata(self, schemata: list[dict[str, Any]]):
        """Replace annotations with ones created according to the given schemata.

        This will be called by concrete subclasses once/whenever they have received the
        annotation metadata.
        """
        self._annotation_schemata = schemata
        self._annotations = []

        def data_source(spec):
            kind = spec["kind"]
            if kind == "fixed":
                return FixedDataSource(spec["value"])

            # `online_result` was called `analysis_result` prior to revision 2, with
            # identical semantics; analysis results proper didn't exit.
            if kind == "online_result" or (
                self.schema_revision < 2 and kind == "analysis_result"
            ):
                analysis = self._online_analyses.get(spec["analysis_name"], None)
                if analysis is None:
                    return None
                return OnlineAnalysisDataSource(analysis, spec["result_key"])
            if kind == "analysis_result":
                name = spec["name"]
                source = self.get_analysis_result_source(name)
                if source is None:
                    logger.info("Analysis result data source not found: %s", name)
                return source

            logger.info("Ignoring unsupported annotation data source type: '%s'", kind)
            return None

        def to_data_sources(specs):
            return {k: data_source(v) for k, v in specs.items()}

        for schema in schemata:
            sources = [to_data_sources(schema.get(n)) for n in ("coordinates", "data")]
            if any(s is None for t in sources for s in t.values()):
                logger.warning("Ignoring analysis, not all data found: %s", schema)
                continue
            self._annotations.append(
                Annotation(schema["kind"], schema.get("parameters", {}), *sources)
            )
        self.annotations_changed.emit(self._annotations)

    def _set_online_analyses(
        self, analysis_schemata: dict[str, dict[str, Any]]
    ) -> None:
        """Create and hook up online analyses from the given schema.

        This will be called by concrete subclasses once/whenever they have received
        the schema metadata.
        """
        for a in self._online_analyses.values():
            a.stop()
        self._online_analyses = {}

        for name, schema in analysis_schemata.items():
            kind = schema["kind"]
            if kind == "named_fit":
                self._online_analyses[name] = OnlineNamedFitAnalysis(schema, self)
            else:
                logger.warning("Ignoring unsupported online analysis type: '%s'", kind)

        # Rebind annotation schemata to new analysis data sources.
        self._set_annotation_schemata(self._annotation_schemata)
